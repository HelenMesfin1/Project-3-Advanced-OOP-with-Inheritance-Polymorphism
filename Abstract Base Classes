#User Management 
class user:
    def __init__(self, username: str, password: str, role: str = "user"):
        self.__username = username
        self.__password = password
        self.__role = role

    @property
    def username(self):
        "getter for username"
        return self.__username

    @property
    def role(self):
        "getter for role"
        return self.__role

    def set_role(self, new_role: str):
        valid_roles = {"user", "admin"}
        if new_role not in valid_roles:
            raise ValueError("Invalid Role.")
        self.__role = new_role

    def verify_password(self, password: str) -> bool:
        return self.__password == password

class manage_users:
    def __init__(self):
        self.__users = {}

    def register_user(self):
        print("Create an account")
        username = input("Enter a username: ").strip()
        password = input("Enter a password: ").strip()

        if username in self.users:
            print("Username already exists.")
            return

        self.__users[username] = User(username, password)
        print(f"User {username} created.")
    
    def login_user(self):
        print("User login")
        username = input("Enter username: ").strip()
        password = input("Enter password: ").strip()

        user = self.__users.get(username)
        if not user:
            print("User not found.")
            return

        if user.verify_password(password):
            print(f"Login success. Welcome {user.username}!")
        else:
            print("Incorrect password.")
class Artwork(ABC):

    "Abstract base class for all artworks."

    def __init__(self, title: str, artist: str, year: int):
        self.title = title
        self.artist = artist
        self.year = year

    @abstractmethod
    def display_info(self) -> str:
        "Must be implemented by subclasses."
        pass
  @property
    def artworks(self):
        "Return a copy of artworks to protect internal data."
        return list(self.__artworks)

    def get_artwork_by_id(self, artwork_id):
        "Return an artwork dictionary by its ID."
        for artwork in self.__artworks:
            if artwork["id"] == artwork_id:
                return artwork
        return None

# Administrative Tools 
    def __init__(self, artworks=None):
        self._artworks = artworks if artworks else []
        self._admin_log = []

    @property
    def artworks(self):
        return list(self._artworks)

    @property
    def admin_log(self):
        return list(self._admin_log)

    def _get_artwork_by_id(self, artwork_id):
        for art in self._artworks:
            if art["id"] == artwork_id:
                return art
        return None

    def _log_action(self, event, user_id="Admin", details=None):
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "user_id": user_id,
            "event": event,
            "details": details or {}
        }
        self._admin_log.append(log_entry)
        return log_entry


#Organization and Tagging
# Derived Class 1
class Painting(Artwork):
    def __init__(self, title, artist, year, medium):
        super().__init__(title, artist, year)
        self.medium = medium  # e.g., Oil, Acrylic, Watercolor

    def display_info(self):
        base_info = super().display_info()
        return f"{base_info} | Painting (Medium: {self.medium})"

# Derived Class 2
class Sculpture(Artwork):
    def __init__(self, title, artist, year, material):
        super().__init__(title, artist, year)
        self.material = material  # e.g., Marble, Bronze, Wood

    def display_info(self):
        base_info = super().display_info()
        return f"{base_info} | Sculpture (Material: {self.material})"

# Derived Class 3
class DigitalArt(Artwork):
    def __init__(self, title, artist, year, file_type):
        super().__init__(title, artist, year)
        self.file_type = file_type  # e.g., JPEG, PNG, GIF
    #Polymorphism: same method called three times, but diffferent objects are created
    def display_info(self):
        base_info = super().display_info()
        return f"{base_info} | Digital Art (File Type: {self.file_type})"


#Artwork Management
class ArtworkManage:
    def __init__(self):
        self.database = []
     def upload_artwork(self, artwork: Artwork, user_id: str):
        """Add artwork to the database, assigning an owner."""
        artwork.owner = user_id
        artwork = {
            "artwork_id": len(self.database),  
            "user_id": user_id,
            "image": artwork_data,
            "title": metadata.get("title"),
            "description": metadata.get("description"),
            "date": metadata.get("date")
        }
        self.database.append(artwork)
        return f"Artwork '{artwork['title']}' uploaded successfully! ID: {artwork['artwork_id']}"
    def edit_artwork(self, artwork_id: int, updated_data: Dict[str, Any]) -> str:
        if artwork_id >= len(self.database) or artwork_id < 0:
            raise IndexError("Artwork not found.")
            
        self.database[artwork_id].update(updated_data)
        return f"Artwork '{self.database[artwork_id].get('title', 'Untitled')}' updated successfully!"
   def delete_artwork(self, artwork_id: int, user_id: str, is_admin: bool = False):
        """Delete artwork only if owned by user or user is admin."""
        art = self._get_by_id(artwork_id)

        if not is_admin and art.owner != user_id:
            raise PermissionError("You cannot delete this artwork.")

        self.database.remove(art)
        return f"Artwork {artwork_id} deleted."
